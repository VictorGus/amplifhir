["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/rc-overflow/lib/hooks/useBatchFrameState.js"],"~:js","shadow$provide.module$node_modules$rc_overflow$lib$hooks$useBatchFrameState=function(global,require,module,exports){global=require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");Object.defineProperty(exports,\"__esModule\",{value:!0});exports.useBatchFrameState=function(){var _useState=(0,_react.useState)({}),forceUpdate=(0,_slicedToArray2.default)(_useState,2)[1],statesRef=(0,_react.useRef)([]),destroyRef=(0,_react.useRef)(!1),walkingIndex=0,beforeFrameId=0;(0,_react.useEffect)(function(){return function(){destroyRef.current=\n!0}},[]);return function(defaultValue){var myIndex=walkingIndex;walkingIndex+=1;statesRef.current.length<myIndex+1&&(statesRef.current[myIndex]=defaultValue);return[statesRef.current[myIndex],function(val){statesRef.current[myIndex]=\"function\"===typeof val?val(statesRef.current[myIndex]):val;_raf.default.cancel(beforeFrameId);beforeFrameId=(0,_raf.default)(function(){destroyRef.current||forceUpdate({})})}]}};var _slicedToArray2=global(require(\"module$node_modules$$babel$runtime$helpers$slicedToArray\")),\n_react=require(\"module$node_modules$react$index\"),_raf=global(require(\"module$node_modules$rc_util$lib$raf\"))}","~:source","shadow$provide[\"module$node_modules$rc_overflow$lib$hooks$useBatchFrameState\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useBatchFrameState = useBatchFrameState;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _react = require(\"react\");\n\nvar _raf = _interopRequireDefault(require(\"rc-util/lib/raf\"));\n\n/**\n * State generate. Return a `setState` but it will flush all state with one render to save perf.\n * This is not a realization of `unstable_batchedUpdates`.\n */\nfunction useBatchFrameState() {\n  var _useState = (0, _react.useState)({}),\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\n      forceUpdate = _useState2[1];\n\n  var statesRef = (0, _react.useRef)([]);\n  var destroyRef = (0, _react.useRef)(false);\n  var walkingIndex = 0;\n  var beforeFrameId = 0;\n  (0, _react.useEffect)(function () {\n    return function () {\n      destroyRef.current = true;\n    };\n  }, []);\n\n  function createState(defaultValue) {\n    var myIndex = walkingIndex;\n    walkingIndex += 1; // Fill value if not exist yet\n\n    if (statesRef.current.length < myIndex + 1) {\n      statesRef.current[myIndex] = defaultValue;\n    } // Return filled as `setState`\n\n\n    var value = statesRef.current[myIndex];\n\n    function setValue(val) {\n      statesRef.current[myIndex] = typeof val === 'function' ? val(statesRef.current[myIndex]) : val;\n\n      _raf.default.cancel(beforeFrameId); // Flush with batch\n\n\n      beforeFrameId = (0, _raf.default)(function () {\n        if (!destroyRef.current) {\n          forceUpdate({});\n        }\n      });\n    }\n\n    return [value, setValue];\n  }\n\n  return createState;\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime$helpers$slicedToArray","~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react$index","~$shadow.js","~$module$node_modules$rc_util$lib$raf"]],"~:properties",["^5",["__esModule","useBatchFrameState","value","current"]],"~:compiled-at",1619101948688,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$rc_overflow$lib$hooks$useBatchFrameState.js\",\n\"lineCount\":3,\n\"mappings\":\"AAAAA,cAAA,CAAe,4DAAf,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrHC,MAAAA,CAAyBH,OAAA,CAAQ,kEAAR,CAE7BI,OAAA,CAAOC,cAAP,CAAsBH,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CI,MAAO,CAAA,CADoC,CAA7C,CAGAJ,QAAA,CAAQK,kBAAR,CAYAA,QAA2B,EAAG,CAAA,IACxBC,UAAY,CAAC,CAAA,CAAGC,MAAH,CAAUC,QAAX,EAAqB,EAArB,CADY,CAGxBC,YADaC,CAAC,CAAA,CAAGC,eAAH,CAAmBC,OAApBF,EAA6BJ,SAA7BI,CAAwC,CAAxCA,CACC,CAAW,CAAX,CAHU,CAKxBG,UAAY,CAAC,CAAA,CAAGN,MAAH,CAAUO,MAAX,EAAmB,EAAnB,CALY,CAMxBC,WAAa,CAAC,CAAA,CAAGR,MAAH,CAAUO,MAAX,EAAmB,CAAA,CAAnB,CANW,CAOxBE,aAAe,CAPS,CAQxBC,cAAgB,CACpB,EAAC,CAAA,CAAGV,MAAH,CAAUW,SAAX,EAAsB,QAAS,EAAG,CAChC,MAAO,SAAS,EAAG,CACjBH,UAAA,CAAWI,OAAX;AAAqB,CAAA,CADJ,CADa,CAAlC,CAIG,EAJH,CAiCA,OA3BAC,SAAoB,CAACC,YAAD,CAAe,CACjC,IAAIC,QAAUN,YACdA,aAAA,EAAgB,CAEZH,UAAJ,CAAcM,OAAd,CAAsBI,MAAtB,CAA+BD,OAA/B,CAAyC,CAAzC,GACET,SAAA,CAAUM,OAAV,CAAkBG,OAAlB,CADF,CAC+BD,YAD/B,CAoBA,OAAO,CAfKR,SAAAT,CAAUe,OAAVf,CAAkBkB,OAAlBlB,CAeL,CAbPoB,QAAiB,CAACC,GAAD,CAAM,CACrBZ,SAAA,CAAUM,OAAV,CAAkBG,OAAlB,CAAA,CAA4C,UAAf,GAAA,MAAOG,IAAP,CAA4BA,GAAA,CAAIZ,SAAA,CAAUM,OAAV,CAAkBG,OAAlB,CAAJ,CAA5B,CAA8DG,GAE3FC,KAAA,CAAKd,OAAL,CAAae,MAAb,CAAoBV,aAApB,CAGAA,cAAA,CAAgB,CAAC,CAAA,CAAGS,IAAH,CAAQd,OAAT,EAAkB,QAAS,EAAG,CACvCG,UAAL,CAAgBI,OAAhB,EACEV,WAAA,CAAY,EAAZ,CAF0C,CAA9B,CANK,CAahB,CAxB0B,CAfP,CAV9B,KAAIE,gBAAkBV,MAAA,CAAuBH,OAAA,CAAQ,0DAAR,CAAvB,CAAtB;AAEIS,OAAST,OAAA,CAAQ,iCAAR,CAFb,CAII4B,KAAOzB,MAAA,CAAuBH,OAAA,CAAQ,qCAAR,CAAvB,CAd8G;\",\n\"sources\":[\"node_modules/rc-overflow/lib/hooks/useBatchFrameState.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$rc_overflow$lib$hooks$useBatchFrameState\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.useBatchFrameState = useBatchFrameState;\\n\\nvar _slicedToArray2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/slicedToArray\\\"));\\n\\nvar _react = require(\\\"react\\\");\\n\\nvar _raf = _interopRequireDefault(require(\\\"rc-util/lib/raf\\\"));\\n\\n/**\\n * State generate. Return a `setState` but it will flush all state with one render to save perf.\\n * This is not a realization of `unstable_batchedUpdates`.\\n */\\nfunction useBatchFrameState() {\\n  var _useState = (0, _react.useState)({}),\\n      _useState2 = (0, _slicedToArray2.default)(_useState, 2),\\n      forceUpdate = _useState2[1];\\n\\n  var statesRef = (0, _react.useRef)([]);\\n  var destroyRef = (0, _react.useRef)(false);\\n  var walkingIndex = 0;\\n  var beforeFrameId = 0;\\n  (0, _react.useEffect)(function () {\\n    return function () {\\n      destroyRef.current = true;\\n    };\\n  }, []);\\n\\n  function createState(defaultValue) {\\n    var myIndex = walkingIndex;\\n    walkingIndex += 1; // Fill value if not exist yet\\n\\n    if (statesRef.current.length < myIndex + 1) {\\n      statesRef.current[myIndex] = defaultValue;\\n    } // Return filled as `setState`\\n\\n\\n    var value = statesRef.current[myIndex];\\n\\n    function setValue(val) {\\n      statesRef.current[myIndex] = typeof val === 'function' ? val(statesRef.current[myIndex]) : val;\\n\\n      _raf.default.cancel(beforeFrameId); // Flush with batch\\n\\n\\n      beforeFrameId = (0, _raf.default)(function () {\\n        if (!destroyRef.current) {\\n          forceUpdate({});\\n        }\\n      });\\n    }\\n\\n    return [value, setValue];\\n  }\\n\\n  return createState;\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"value\",\"useBatchFrameState\",\"_useState\",\"_react\",\"useState\",\"forceUpdate\",\"_useState2\",\"_slicedToArray2\",\"default\",\"statesRef\",\"useRef\",\"destroyRef\",\"walkingIndex\",\"beforeFrameId\",\"useEffect\",\"current\",\"createState\",\"defaultValue\",\"myIndex\",\"length\",\"setValue\",\"val\",\"_raf\",\"cancel\"]\n}\n"]